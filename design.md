# 规则数据库设计原理

## 规则编译器
规则编译器将规则编译为虚拟机代码和 DFA。

编译分为两阶段，第一阶段解析规则，提取精确查询词和(复合)正则表达式，统称为原子，每个原子分配一个 id。

对于 near 子表达式中嵌套 near 和 or 的场景，使用分配律对语法树进行变换。

最后生成规则虚拟机代码和原子ID到规则ID映射的 postinglist。同时将原子输出到文本文件，作为第二阶段的输入。

第二阶段调用 ac 自动机和 **多正则**引擎 编译器 将原子编译成 DFA。

## 匹配引擎
高性能的 AC 自动机和 多正则 引擎是 Topling 的核心技术。

1. AC 自动机基于双数组 Trie 树，客户反映无论是编译还是匹配，比他用过的某知名软件的 AC 模块都快一个数量级并且内存占用小一个数量级。
1. 多正则 引擎源于我们最早10年前的技术，经多年改进而成，高层支持正则代数运算与DFA最小化，底层将DFA编译为虚拟机，空间占用比传统 DFA 小两个数量级，性能高一个数量级。

### 为每个字段单独建库
第一阶段提取的原子是按字段分离的，如果一个词在不同字段中均有出现，视为不同的原子。

1. 为精确查询词构建 AC 自动机来实现多模匹配
1. 为(复合)正则表达式构建 DFA 实现多正则匹配

如果有很多字段，就需要构建很多 AC 自动机与正则表达式 DFA，所以第一阶段生成一个 Makefile，在第二阶段可以并行编译。

### bool 表达式短路运算

对于`中国 and 美国`，如果未发现`中国`，则不会再匹配美国。

对于`中国 or 美国`，如果已发现`中国`，则不会再匹配美国。

对于更复杂的 bool 表达式，短路运算可以大幅提升性能。

### anyof, allof

虽然 bool 表达式短路运算可以提升不少性能，但是它不考虑词频：词频低的更难命中，词频高的更容易命中。

所以规则编译器有个优化：对于一个仅包含原子的 and 或 or 的表达式，自动生成 allof 和 anyof，并按词频排序，对于 allof，词频低的在前，对于 anyof，词频高的在前。

并且，相比多条 and 和 or 以及原子匹配，allof 和 anyof 的虚拟机代码更短。

> 需要 rule_db_build.sh -W word_freq_file 传入词频定义(word \\t freq)，否则没有词频优化

### 链式 near

一般的 near 表达式的两个子表达式都是原子，并且作为 or 或 and 的子表达式出现。这会直接生成单个虚拟机的原子 near 指令。

链式 near 是形如这样的 near：

```
中国 near/+3 人民 near/+5 勤劳 near/+7 勇敢
```

其语义遵守人类的思维方式，表示这 4 个词项按顺序出现并满足距离约束。根据正则语言代数规则，同一个链式 near 表达式中所有的方向都相同（距离数值有-+号）时，其运算遵守结合律。

所以无论加括号是怎样写的，其实际执行的加括号均是：
```
((中国 near/+3 人民) near/+5 勤劳) near/+7 勇敢
```
其中每个加括号的结果(位置集合)与右侧原子词项进行 near 运算。

然而对于混合方向以及双向near(距离数值没有-+号)，按正则语言代数规则的结合律并不成立，但我们在这里忽略这个细节，计算结果会有一些微妙的区别，但这些区别更多是对计算机而言的，对于人类来讲这些微妙区别并不重要。所以我们总按左结合运算顺序加括号，这大幅提高了计算性能。

## 匹配阶段

在执行文档匹配时，先使用 AC 自动机和多正则 DFA 分别扫描一遍，记录匹配位置和长度。然后查找 postinglist 召回规则ID。对于每条规则，执行规则虚拟机代码进行验证，看是否匹配。

## 规则虚拟机

规则虚拟机是个栈式变长指令虚拟机，not, and, or, regex, exact, jmp 是简单指令，每条指令占 4 字节。 near, allof, anyof 是变长指令，占多个字节。

指令的执行结果会放入栈顶，not, and, or 从栈顶取参数并将结果重新放入栈顶。

每条规则运行结束时，栈中剩余并且仅剩余一个元素，就是最终的匹配结果：true 或 false。
