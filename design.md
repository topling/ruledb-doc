# 规则数据库设计原理

## 规则编译器
规则编译器将规则编译为虚拟机代码和 DFA。

编译分为两阶段，第一阶段解析规则，提取精确查询词和(复合)正则表达式，统称为原子，每个原子分配一个 id。

对于 near 子表达式中嵌套 near 和 or 的场景，使用分配率对语法树进行变换。

最后生成规则虚拟机代码和原子ID到规则ID映射的 postinglist。同时将原子输出到文本文件，作为第二阶段的输入。

第二阶段调用 ac 自动机和 **多正则**引擎 编译器 将原子编译成 DFA。

### 为每个字段单独建库
第一阶段提取的原子是按字段分离的，如果一个词在不同字段中均有出现，视为不同的原子。

1. 为精确查询词构建 AC 自动机来实现多模匹配
1. 为(复合)正则表达式构建 DFA 实现多正则匹配

如果有很多字段，就需要构建很多 AC 自动机与正则表达式 DFA，所以第一阶段生成一个 Makefile，在第二阶段可以并行编译。

### bool 表达式短路运算

对于`中国 and 美国`，如果未发现`中国`，则不会再匹配美国。

对于`中国 or 美国`，如果已发现`中国`，则不会再匹配美国。

对于更复杂的 bool 表达式，短路运算可以大幅提升性能。

### anyof, allof

虽然 bool 表达式短路运算可以提升不少性能，但是它不考虑词频：词频低的更难命中，词频高的更容易命中。

所以规则编译器有个优化：对于一个仅包含原子的 and 或 or 的表达式，自动生成 allof 和 anyof，并按词频排序，对于 allof，词频低的在前，对于 anyof，词频高的在前。

并且，相比多条 and 和 or 以及原子匹配，allof 和 anyof 的虚拟机代码更短。

> 需要 rule_db_build.sh -W word_freq_file 传入词频定义(word \\t freq)，否则没有词频优化

### 链式 near

一般的 near 表达式的两个子表达式都是原子，并且作为 or 或 and 的子表达式出现。这会直接生成单个虚拟机的原子 near 指令。

对于链式 near 和复合 near，会生成复合 near 指令，并通过 and 逻辑连接起来，其中的 and 同样进行短路优化。

## 匹配阶段

在执行文档匹配时，先使用 AC 自动机和多正则 DFA 分别扫描一遍，记录匹配位置和长度。然后查找 postinglist 召回规则ID。对于每条规则，执行规则虚拟机代码进行验证，看是否匹配。

## 规则虚拟机

规则虚拟机是个栈式变长指令虚拟机，not, and, or, regex, exact, jmp 是简单指令，每条指令占 4 字节。 near, allof, anyof 是变长指令，占多个字节。

指令的执行结果会放入栈顶，not, and, or 从栈顶取参数并将结果重新放入栈顶。

每条规则运行结束时，栈中剩余并且仅剩余一个元素，就是最终的匹配结果：true 或 false。
